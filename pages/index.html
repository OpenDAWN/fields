<!doctype html>

<html>
  
  <head>
    <style>
      body {
        font-size: 40px;
        background-color: LightGrey;
        padding: 40px;
      }

      #notSupported {
        padding: 30px;
        font-size: 150%;
        color: red;
      }

      #console {
        background-color: #9fffff;
      }

      #pending {
        display: none;
      }

      #status {
        position: fixed;
        bottom: 0;
        right: 0;
      }

      #startButton {
        width: 100%;
        font-size: 100%;
        color: blue;
        background-color: white;
        border: 1px solid black;
        padding: 1em 1em;
      }

      .imgP {
        text-align: center;
      }

      h1 {
        width: 100%;
        text-align: center;
      }

      p {
        color: #444;
      }

      button {
        font-size: 100px;
      }
    </style>
    <script src="js/AudioContextMonkeyPatch.js"></script>
    <script src="js/jquery-2.1.0.js"></script>
    <script src="js/WAAClock-0.3.1.js"></script>
    <script src="/rhizome/rhizome.js"></script>
    <script>
      var Grains = function(url) {
        this.params = {
          position: [0, 0],
          duration: [0.1, 0],
          ratio: [0.5, 0],
          env: 1,
          volume: 0,
          density: 0,
          mode: 'off'
        }
        this.url = url
        this.mixer = null
        this.grainCount = 0 // grain counter
        this.ready = false // true when the samples are loaded
      }

      Grains.prototype.getPosition = function() {
        var mean = this.params.position[0]
          * (buffers[this.url].length / audioContext.sampleRate)
        return 0 + pickVal(mean, this.params.position[1])
      }

      Grains.prototype.getDuration = function() {
        var mean = this.params.duration[0]
        return Math.max(0.01, pickVal(4 * valExp(mean), this.params.duration[1]))
      }

      Grains.prototype.getVolume = function() {
        return valExp(this.params.volume, 2.5)
      }

      Grains.prototype.getRatio = function() {
        var meanRatio = this.params.ratio[0]
        if (this.params.quantize_ratio) {
          return meanRatio * ratios[Math.floor(Math.random() * 0.99 * ratios.length)]
        } else return Math.max(0.05, pickVal(meanRatio, this.params.ratio[1]))
      }
      var ratios = [0.5, 0.75, 1]

      // Returns true for silence, false for grain.
      // There is twice as much chance as expected from the density 
      // to pick up a silence, but silences should be twice shorter.
      Grains.prototype.enjoyTheSilence = function() {
        var pick1 = Math.random() > this.params.density
          , pick2 = Math.random() > this.params.density
        return pick1 || pick2
      }

      Grains.prototype.setMode = function(mode) {
        log('MODE ' + this.url + ' ' + mode)
        if (this.grainEvent) this.grainEvent.clear()
        if (mode === 'off') return
        
        var self = this
          , repeatFunc
        this.mixer = audioContext.createGain()
        this.mixer.connect(audioContext.destination)

        // If grains, the silence is randomized according to density
        if (mode === 'grains') {
          repeatFunc = function() {
            var duration = self.getDuration()
            if (self.enjoyTheSilence()) self.grainEvent.repeat(duration / 2 || 0.005)
            else {
              self.mixer.gain.value = self.getVolume()
              duration = playSound(self.url, self.mixer, self.getPosition()
                , duration, self.getRatio(), self.params.env)
              self.grainEvent.repeat(duration || 0.005)
            }
          }

        // If we are looping, we play 1 grain silence, 1 grain sound
        } else if (mode === 'loop') {
          repeatFunc = function() {
            var duration = self.getDuration()
            self.grainCount++
            if ((self.grainCount % 2) === 0) {
              self.grainEvent.repeat((duration * (1 - self.params.density) * 4) || 0.005)
            } else {
              self.mixer.gain.value = self.getVolume()
              duration = playSound(self.url, self.mixer, self.getPosition()
                , duration, self.getRatio(), self.params.env)
              self.grainEvent.repeat(duration || 0.005)
            }
          }
        }

        this.grainEvent = clock.setTimeout(repeatFunc, 0.1)
        this.grainEvent.repeat(0.1)
      }

      Grains.prototype.loadBuffer = function(done) {
        var self = this
        loadBuffer(this.url, function(err, buffer, url) {
          if (err) log(err)
          else {
            log('loaded ' + url + ' , samples : ' + buffer.length)
            buffers[self.url] = buffer
            done()
          }
        })        
      }

      var audioContext
        , clock
        , buffers = {}
        , grainsDict = {
          '1': new Grains('sounds/uk_terns'),
          '2': new Grains('sounds/wood_cracks_boosted'),
          '3': new Grains('sounds/violin_fields'), // ambient violins
          '4': new Grains('sounds/fields_drops'), // bowed violin
          '5': new Grains('sounds/fields_waves_boosted')
        }

      var onServerFull = function() {
        $('#pending').show().html('The system is full at the moment. You are in the queue and will be join as soon as there is space.')
        $('#status').html('status: waiting')
      }

      var onConnected = function() {
        $('#pending').hide()
        $('#status').html('status: connected')
        var id, grains
        for (id in grainsDict) {
          grains = grainsDict[id]
          grains.loadBuffer((function(grains) {
            return function() {
              grains.ready = true
              grains.setMode(grains.params.mode)
            }
          })(grains))
        }
        doSubscribe()
        doResend()
      }

      var onConnectionLost = function() {
        $('#status').html('status: reconnecting ...')
        for (id in grainsDict) grainsDict[id].setMode('off')        
      }

      var onReconnected = function() {
        $('#pending').hide()
        $('#status').html('status: connected')
        doSubscribe()
        doResend()
        for (id in grainsDict) {
          grainsDict[id].setMode(grainsDict[id].params.mode)
        }        
      }

      rhizome.on('connected', onConnected)
      rhizome.on('server full', onServerFull)
      rhizome.on('connection lost', onConnectionLost)
      rhizome.on('reconnected', onReconnected)

      var doSubscribe = function() {
        var addresses = ['/volume', '/density', '/position'
          , '/duration', '/ratio', '/env', '/mode', '/quantize_ratio'
          , '/randomize_position']
        var id, i
        for (id in grainsDict) {
          for (i = 0; i < addresses.length; i++)
            rhizome.send('/sys/subscribe', ['/grains/' + id + addresses[i]])
        }
      }

      var doResend = function() {
        var addresses = ['/volume', '/density', '/position'
          , '/duration', '/ratio', '/env', '/mode/1/1', '/mode/1/2'
          , '/mode/1/3', '/quantize_ratio']
        var id, i
        for (id in grainsDict) {
          for (i = 0; i < addresses.length; i++)
            rhizome.send('/sys/resend', ['/grains/' + id + addresses[i]])
        }
      }

      var onMessage = function(address, args) {
        if (address === '/sys/subscribed') 1 // log('subscribed ' + args[0])
        else {
          var tokens = address.split('/').slice(1)
            , mode = tokens[0]
          if (mode === 'grains') {
            var id = tokens[1]
              , param = tokens[2]

            if (param === 'volume' || param === 'density'
              || param === 'env' || param === 'quantize_ratio') {
              grainsDict[id].params[param] = args[0]

            } else if (param === 'randomize_position') { 
              grainsDict[id].params.position[0] = Math.random()

            } else if (param === 'mode') {
              if (args[0] === 1) {
                var mode = ['off', 'grains', 'loop'][parseInt(tokens[4], 10) - 1]
                grainsDict[id].params.mode = mode
                if (grainsDict[id].ready) grainsDict[id].setMode(mode)
              }
            } else {
              grainsDict[id].params[param] = [args[1], args[0]] // x and y are inverted
            }
          }
        }
      }
      rhizome.on('message', onMessage)

      // TODO: somehow this doesn't work when duration * ratio is bigger than buffer even if recalculating duration.
      var playSound = function(url, sink, start, duration, ratio, env) {
        var buffer = buffers[url]
          , bufDuration = buffer.length / audioContext.sampleRate
          , availDur = bufDuration - start

        duration = Math.min(availDur / ratio, duration)
        if (duration <= 0) return 0

        var bufferNode = audioContext.createBufferSource()
          , gainNode = audioContext.createGain()

        bufferNode.playbackRate.value = ratio
        bufferNode.buffer = buffer

        var rampDur = Math.max(duration * (env / 2), 0.002)
        gainNode.gain.setValueAtTime(0, audioContext.currentTime)
        gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + rampDur)
        gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + duration - rampDur)
        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration)

        bufferNode.connect(gainNode)
        gainNode.connect(sink)
        bufferNode.start(0, start, duration)

        return duration
      }

      var loadBuffer = function(url, done) {
        loadFile(url + '.ogg', function(err, blob) {
          if (err) return done(err)
          decodeBlob(blob, function(err, buffer) {
            if (!err) return done(null, buffer, url + '.ogg')

            loadFile(url + '.mp3', function(err, blob) {
              if (err) return done(err)
              decodeBlob(blob, function(err, buffer) {
                if (!err) return done(null, buffer, url + '.mp3')
                else done(new Error('cant decode ' + url))
              })
            })

          })
        })
      }

      var decodeBlob = function(blob, done) {
        audioContext.decodeAudioData(blob, function(buffer) {
          done(null, buffer)
        }, function(err) {
          done(err || new Error('decoding error'), null)
        })
      }

      var loadFile = function(url, done) {
        var request = new XMLHttpRequest()
        request.open('GET', url, true)
        request.responseType = 'arraybuffer'
        request.onload = function() {
          done(null, request.response)
        }
        request.onerror = function(err) {
          done(err || new Error('unexpected request error'), null)
        }
        request.send()
      }

      var pickVal = function(mean, variance) {
        return mean + mean * variance * (1 - 2 * Math.random())
      }

      var floor = function(val, dec) {
        return Math.floor(val * Math.pow(10, dec)) / Math.pow(10, dec) 
      }

      var valExp = function(val, exp) {
        exp = exp || 2
        return (Math.exp(val * exp) - Math.exp(0)) / (Math.exp(exp) - Math.exp(0))
      }

      var startPressed = function() {
        // We need to create the audio context in response to a user action,
        // and we also need to force the dsp to start by for example starting
        // an oscillator.
        audioContext = new AudioContext()
        clock = new WAAClock(audioContext)
        var osc = audioContext.createOscillator()
          , gain = audioContext.createGain()
        gain.gain.value = 0
        osc.connect(gain)
        osc.frequency.value = 440
        gain.connect(audioContext.destination)
        osc.start(0)
        osc.stop(1)
        rhizome.start()
        $('#instructions').fadeOut(3000)
        $('#status').html('status: connecting ...')
      }
    </script>
    <script>
      var log = function(msg) {
        $('<div>', { class: 'log' })
          .html(msg)
          .prependTo('#console')
      }
      //if (typeof rhizome !== 'undefined') rhizome.log = log

      var isSupported = function() {
        if (typeof rhizome === 'undefined' || rhizome.isSupported()) {
          if (window.AudioContext) return true
          else return false
        } else return false
        return false
      }
    </script>
  </head>

  <body>
    <div id="pending"></div>
    <div id="instructions">
      <h1>Fields)_(</h1>
      <p>Hello, welcome to <b>)))Fields(((</b>. To ensure a full experience, here are a few instructions.</p>
      <p><b>1.</b> put the volume of the device to maximum.</p>
      <p><b>2.</b> make sure your phone is not on mute.</p>
      <p class="imgP"><img src="images/unmute.gif"/></p>
      <p><b>3.</b> if your device go to sleep mode, wake it up.</p>
      <p><b>4.</b> if your device seems to be stuck, reload the page and reconnect.</p>
      <p><b>5.</b> when you're ready, press the start button below.</p>

      <button id="startButton" onclick="startPressed();">Start</button>
    </div>
    <div id="console"></div>
    <div id="status"></div>
    <script>
      if (!isSupported()) {
        log('Device not supported')
        $('#instructions').html('<div id="notSupported">Sorry, but this web browser is not supported by our system. You should try with a recent version of Chrome or Firefox.</div>')
      } else {
        log('Device is supported')
      }
    </script>

  </body>
  
</html>