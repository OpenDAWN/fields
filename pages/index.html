<!doctype html>

<html>
  
  <head>
    <style>
      body {
        font-size: 30px;
      }

      button {
        font-size: 100px;
      }
    </style>
    <script src="js/AudioContextMonkeyPatch.js"></script>
    <script src="js/jquery-2.1.0.js"></script>
    <script src="js/WAAClock-0.3.1.js"></script>
    <script src="/rhizome/rhizome.js"></script>
    <script>
      var Grains = function(url) {
        this.params = {
          position: [0, 0],
          duration: [0.1, 0],
          ratio: [0.5, 0],
          env: 0
        }
        this.url = url
      }

      Grains.prototype.getPosition = function() {
        var mean = this.params.position[0]
          * (buffers[this.url].length / audioContext.sampleRate)
        return 0 + pickVal(mean, this.params.position[1])
      }

      Grains.prototype.getDuration = function() {
        var mean = this.params.duration[0]
        mean = (Math.exp(mean * 2) - Math.exp(0)) / (Math.exp(2) - Math.exp(0))
        return Math.max(0.01, pickVal(4 * mean, this.params.duration[1]))
      }

      Grains.prototype.getRatio = function() {
        return Math.max(0.05, pickVal(this.params.ratio[0], this.params.ratio[1]))
      }

      Grains.prototype.getEnv = function() {
        return ['rectangle', 'triangle'][this.params.env]
      }

      Grains.prototype.start = function() {
        var self = this
        this.grainEvent = clock.setTimeout(function() {
          var duration = self.getDuration()
          duration = playSound(
            self.url,
            self.getPosition(),
            duration,
            self.getRatio(),
            self.getEnv()
          )
          self.grainEvent.repeat(duration || 0.005)
        }, 0.1)
        self.grainEvent.repeat(0.1)
      }

      Grains.prototype.stop = function() {
        log('stop ' + this.grainEvent)
        if (this.grainEvent) this.grainEvent.clear()
      }


      Grains.prototype.loadBuffer = function(done) {
        var self = this
        loadBuffer(this.url, function(err, buffer) {
          if (err) log(err)
          else {
            log('loaded ' + self.url + ' , samples : ' + buffer.length)
            buffers[self.url] = buffer
            done()
          }
        })        
      }

      var audioContext
        , clock
        , buffers = {}
        , grainsDict = {
          '1': new Grains('sounds/chimes.wav')
        }

      var onConnected = function() {
        doSubscribe()
        doResend()
        var id, grains
        for (id in grainsDict) {
          grains = grainsDict[id]
          grains.loadBuffer((function(grains) {
            return function() { grains.start() }
          })(grains))
        }
      }

      // TODO
      var onServerFull = function() {

      }

      var onConnectionLost = function() {
        for (id in grainsDict) {
          grainsDict[id].stop()
        }        
      }

      var onReconnected = function() {
        doSubscribe()
        for (id in grainsDict) {
          grainsDict[id].start()
        }        
      }

      rhizome.on('connected', onConnected)
      rhizome.on('server full', onServerFull)
      rhizome.on('connection lost', onConnectionLost)
      rhizome.on('reconnected', onReconnected)

      var doSubscribe = function() {
        rhizome.send('/sys/subscribe', ['/grains/1/position'])
        rhizome.send('/sys/subscribe', ['/grains/1/duration'])
        rhizome.send('/sys/subscribe', ['/grains/1/ratio'])
        rhizome.send('/sys/subscribe', ['/grains/1/env/1/1'])
        rhizome.send('/sys/subscribe', ['/grains/1/env/1/2'])
      }

      var doResend = function() {
        rhizome.send('/sys/resend', ['/grains/1/position'])
        rhizome.send('/sys/resend', ['/grains/1/duration'])
        rhizome.send('/sys/resend', ['/grains/1/ratio'])
        rhizome.send('/sys/resend', ['/grains/1/env/1/1'])
        rhizome.send('/sys/resend', ['/grains/1/env/1/2'])
      }

      var onMessage = function(address, args) {
        if (address === '/sys/subscribed') {
          log('subscribed ' + args[0])
        } else {
          var tokens = address.split('/').slice(1)
            , mode = tokens[0]
          if (mode === 'grains') {
            var id = tokens[1]
              , param = tokens[2]
            if (param === 'env') {
              if (args[0] === 1) {
                grainsDict[id].params.env = tokens[4] - 1
              }
            } else {
              grainsDict[id].params[param] = [args[1], args[0]] // x and y are inverted
            }
          }
        }
      }
      rhizome.on('message', onMessage)

      // TODO: somehow this doesn't work when duration * ratio is bigger than buffer even if recalculating duration.
      var playSound = function(url, start, duration, ratio, env) {
        var buffer = buffers[url]
          , bufDuration = buffer.length / audioContext.sampleRate
          , availDur = bufDuration - start

        duration = Math.min(availDur / ratio, duration)
        if (duration <= 0) return 0

        var bufferNode = audioContext.createBufferSource()
          , gainNode = audioContext.createGain()
        bufferNode.playbackRate.value = ratio
        bufferNode.buffer = buffer

        if (env === 'triangle') {
          gainNode.gain.setValueAtTime(0, audioContext.currentTime)
          gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + duration / 2)
          gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration)
        } else if (env === 'rectangle') {
          gainNode.gain.setValueAtTime(0, audioContext.currentTime)
          gainNode.gain.setValueAtTime(1, audioContext.currentTime + 0.002)
          gainNode.gain.setValueAtTime(0, audioContext.currentTime + duration - 0.002)
        }
        else throw new Error('invalid enveloppe')

        bufferNode.connect(gainNode)
        gainNode.connect(audioContext.destination)
        bufferNode.start(0, start, duration)

        return duration
      }

      var loadBuffer = function(url, done) {
        var request = new XMLHttpRequest()
        request.open('GET', url, true)
        request.responseType = 'arraybuffer'
        request.onload = function() {
          audioContext.decodeAudioData(request.response, function(buffer) {
            done(null, buffer)
          }, function(err) {
            done(err || new Error('decoding error'), null)
          })
        }
        request.onerror = function(err) {
          done(err || new Error('unexpected request error'), null)
        }
        request.send()
      }

      var pickVal = function(mean, variance) {
        return mean + mean * variance * (1 - 2 * Math.random())
      }

      var floor = function(val, dec) {
        return Math.floor(val * Math.pow(10, dec)) / Math.pow(10, dec) 
      }

      var startPressed = function() {
        // We need to create the audio context in response to a user action,
        // and we also need to force the dsp to start by for example starting
        // an oscillator.
        audioContext = new AudioContext()
        clock = new WAAClock(audioContext)
        var osc = audioContext.createOscillator()
          , gain = audioContext.createGain()
        gain.gain.value = 0
        osc.connect(gain)
        osc.frequency.value = 440
        gain.connect(audioContext.destination)
        osc.start(0)
        osc.stop(1)
        rhizome.start()
      }
    </script>
    <script>
      var log = function(msg) {
        $('<div>', { class: 'log' })
          .html(msg)
          .prependTo('#console')
      }
      //if (typeof rhizome !== 'undefined') rhizome.log = log

      var isSupported = function() {
        if (typeof rhizome === 'undefined' || rhizome.isSupported()) {
          if (window.AudioContext) return true
          else return false
        } else return false
        return false
      }
    </script>
  </head>

  <body>
    <button id="startButton" onclick="startPressed();">Start</button>
    <div id="console"></div>
    <script>
      if (!isSupported()) log('Device not supported')
      else log('Device is supported')
    </script>

  </body>
  
</html>