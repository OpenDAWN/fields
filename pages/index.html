<!doctype html>

<html>
  
  <head>
    <style>
      body {
        font-size: 30px;
      }

      button {
        font-size: 100px;
      }
    </style>
    <script src="js/AudioContextMonkeyPatch.js"></script>
    <script src="js/jquery-2.1.0.js"></script>
    <script src="js/WAAClock-0.3.1.js"></script>
    <script src="/rhizome/rhizome.js"></script>
    <script>
      var Grains = function(url) {
        this.params = {
          position: [0, 0],
          duration: [0.1, 0],
          ratio: [0.5, 0],
          env: 1,
          volume: 0,
          density: 0,
          mode: 'off'
        }
        this.url = url
        this.mixer = null
        this.grainCount = 0 // grain counter
        this.ready = false // true when the samples are loaded
      }

      Grains.prototype.getPosition = function() {
        var mean = this.params.position[0]
          * (buffers[this.url].length / audioContext.sampleRate)
        return 0 + pickVal(mean, this.params.position[1])
      }

      Grains.prototype.getDuration = function() {
        var mean = this.params.duration[0]
        mean = (Math.exp(mean * 2) - Math.exp(0)) / (Math.exp(2) - Math.exp(0))
        return Math.max(0.01, pickVal(4 * mean, this.params.duration[1]))
      }

      Grains.prototype.getRatio = function() {
        return Math.max(0.05, pickVal(this.params.ratio[0], this.params.ratio[1]))
      }

      // Returns true for silence, false for grain.
      // There is twice as much chance as expected from the density 
      // to pick up a silence, but silences should be twice shorter.
      Grains.prototype.enjoyTheSilence = function() {
        var pick1 = Math.random() > this.params.density
          , pick2 = Math.random() > this.params.density
        return pick1 || pick2
      }

      Grains.prototype.setMode = function(mode) {
        log('MODE ' + mode)
        if (this.grainEvent) this.grainEvent.clear()
        if (mode === 'off') return
        
        var self = this
          , repeatFunc
        this.mixer = audioContext.createGain()
        this.mixer.connect(audioContext.destination)

        // If grains, the silence is randomized according to density
        if (mode === 'grains') {
          repeatFunc = function() {
            var duration = self.getDuration()
            if (self.enjoyTheSilence()) self.grainEvent.repeat(duration / 2 || 0.005)
            else {
              self.mixer.gain.value = self.params.volume
              duration = playSound(self.url, self.mixer, self.getPosition()
                , duration, self.getRatio(), self.params.env)
              self.grainEvent.repeat(duration || 0.005)
            }
          }

        // If we are looping, we play 1 grain silence, 1 grain sound
        } else if (mode === 'loop') {
          repeatFunc = function() {
            var duration = self.getDuration()
            self.grainCount++
            if ((self.grainCount % 2) === 0) {
              self.grainEvent.repeat((duration * (1 - self.params.density) * 4) || 0.005)
            } else {
              self.mixer.gain.value = self.params.volume
              duration = playSound(self.url, self.mixer, self.getPosition()
                , duration, self.getRatio(), self.params.env)
              self.grainEvent.repeat(duration || 0.005)
            }
          }
        }

        this.grainEvent = clock.setTimeout(repeatFunc, 0.1)
        this.grainEvent.repeat(0.1)
      }

      Grains.prototype.loadBuffer = function(done) {
        var self = this
        loadBuffer(this.url, function(err, buffer) {
          if (err) log(err)
          else {
            log('loaded ' + self.url + ' , samples : ' + buffer.length)
            buffers[self.url] = buffer
            done()
          }
        })        
      }

      var audioContext
        , clock
        , buffers = {}
        , grainsDict = {
          '1': new Grains('sounds/uk_terns.wav'),
          '2': new Grains('sounds/slow_wood_short.wav')
        }

      var onConnected = function() {
        var id, grains
        for (id in grainsDict) {
          grains = grainsDict[id]
          grains.loadBuffer((function(grains) {
            return function() {
              grains.ready = true
              grains.setMode(grains.params.mode)
            }
          })(grains))
        }

        doSubscribe()
        doResend()
      }

      // TODO
      var onServerFull = function() {

      }

      var onConnectionLost = function() {
        for (id in grainsDict) {
          grainsDict[id].setMode('off')
        }        
      }

      var onReconnected = function() {
        doSubscribe()
        doResend()
        for (id in grainsDict) {
          grainsDict[id].setMode(grainsDict[id].params.mode)
        }        
      }

      rhizome.on('connected', onConnected)
      rhizome.on('server full', onServerFull)
      rhizome.on('connection lost', onConnectionLost)
      rhizome.on('reconnected', onReconnected)

      var doSubscribe = function() {
        rhizome.send('/sys/subscribe', ['/grains/1/volume'])
        rhizome.send('/sys/subscribe', ['/grains/1/density'])
        rhizome.send('/sys/subscribe', ['/grains/1/position'])
        rhizome.send('/sys/subscribe', ['/grains/1/duration'])
        rhizome.send('/sys/subscribe', ['/grains/1/ratio'])
        rhizome.send('/sys/subscribe', ['/grains/1/env'])
        rhizome.send('/sys/subscribe', ['/grains/1/mode'])

        rhizome.send('/sys/subscribe', ['/grains/2/volume'])
        rhizome.send('/sys/subscribe', ['/grains/2/density'])
        rhizome.send('/sys/subscribe', ['/grains/2/position'])
        rhizome.send('/sys/subscribe', ['/grains/2/duration'])
        rhizome.send('/sys/subscribe', ['/grains/2/ratio'])
        rhizome.send('/sys/subscribe', ['/grains/2/env'])
        rhizome.send('/sys/subscribe', ['/grains/2/mode'])
      }

      var doResend = function() {
        rhizome.send('/sys/resend', ['/grains/1/volume'])
        rhizome.send('/sys/resend', ['/grains/1/density'])
        rhizome.send('/sys/resend', ['/grains/1/position'])
        rhizome.send('/sys/resend', ['/grains/1/duration'])
        rhizome.send('/sys/resend', ['/grains/1/ratio'])
        rhizome.send('/sys/resend', ['/grains/1/env'])
        rhizome.send('/sys/resend', ['/grains/1/mode/1/1'])
        rhizome.send('/sys/resend', ['/grains/1/mode/1/2'])
        rhizome.send('/sys/resend', ['/grains/1/mode/1/3'])

        rhizome.send('/sys/resend', ['/grains/2/volume'])
        rhizome.send('/sys/resend', ['/grains/2/density'])
        rhizome.send('/sys/resend', ['/grains/2/position'])
        rhizome.send('/sys/resend', ['/grains/2/duration'])
        rhizome.send('/sys/resend', ['/grains/2/ratio'])
        rhizome.send('/sys/resend', ['/grains/2/env'])
        rhizome.send('/sys/resend', ['/grains/2/mode/1/1'])
        rhizome.send('/sys/resend', ['/grains/2/mode/1/2'])
        rhizome.send('/sys/resend', ['/grains/2/mode/1/3'])
      }

      var onMessage = function(address, args) {
        if (address === '/sys/subscribed') {
          log('subscribed ' + args[0])
        } else {
          var tokens = address.split('/').slice(1)
            , mode = tokens[0]
          if (mode === 'grains') {
            var id = tokens[1]
              , param = tokens[2]

            if (param === 'volume' || param === 'density' || param === 'env') {
              grainsDict[id].params[param] = args[0]

            } else if (param === 'mode') {
              if (args[0] === 1) {
                var mode = ['off', 'grains', 'loop'][parseInt(tokens[4], 10) - 1]
                console.log(mode, tokens[4], parseInt(tokens[4], 10) - 1)
                grainsDict[id].params.mode = mode
                if (grainsDict[id].ready) grainsDict[id].setMode(mode)
              }

            } else {
              grainsDict[id].params[param] = [args[1], args[0]] // x and y are inverted
            }
          }
        }
      }
      rhizome.on('message', onMessage)

      // TODO: somehow this doesn't work when duration * ratio is bigger than buffer even if recalculating duration.
      var playSound = function(url, sink, start, duration, ratio, env) {
        var buffer = buffers[url]
          , bufDuration = buffer.length / audioContext.sampleRate
          , availDur = bufDuration - start

        duration = Math.min(availDur / ratio, duration)
        if (duration <= 0) return 0

        var bufferNode = audioContext.createBufferSource()
          , gainNode = audioContext.createGain()
        bufferNode.playbackRate.value = ratio
        bufferNode.buffer = buffer

        var rampDur = Math.max(duration * (env / 2), 0.002)
        gainNode.gain.setValueAtTime(0, audioContext.currentTime)
        gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + rampDur)
        gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + duration - rampDur)
        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration)

        bufferNode.connect(gainNode)
        gainNode.connect(sink)
        bufferNode.start(0, start, duration)

        return duration
      }

      var loadBuffer = function(url, done) {
        var request = new XMLHttpRequest()
        request.open('GET', url, true)
        request.responseType = 'arraybuffer'
        request.onload = function() {
          audioContext.decodeAudioData(request.response, function(buffer) {
            done(null, buffer)
          }, function(err) {
            done(err || new Error('decoding error'), null)
          })
        }
        request.onerror = function(err) {
          done(err || new Error('unexpected request error'), null)
        }
        request.send()
      }

      var pickVal = function(mean, variance) {
        return mean + mean * variance * (1 - 2 * Math.random())
      }

      var floor = function(val, dec) {
        return Math.floor(val * Math.pow(10, dec)) / Math.pow(10, dec) 
      }

      var startPressed = function() {
        // We need to create the audio context in response to a user action,
        // and we also need to force the dsp to start by for example starting
        // an oscillator.
        audioContext = new AudioContext()
        clock = new WAAClock(audioContext)
        var osc = audioContext.createOscillator()
          , gain = audioContext.createGain()
        gain.gain.value = 0
        osc.connect(gain)
        osc.frequency.value = 440
        gain.connect(audioContext.destination)
        osc.start(0)
        osc.stop(1)
        rhizome.start()
      }
    </script>
    <script>
      var log = function(msg) {
        $('<div>', { class: 'log' })
          .html(msg)
          .prependTo('#console')
      }
      //if (typeof rhizome !== 'undefined') rhizome.log = log

      var isSupported = function() {
        if (typeof rhizome === 'undefined' || rhizome.isSupported()) {
          if (window.AudioContext) return true
          else return false
        } else return false
        return false
      }
    </script>
  </head>

  <body>
    <button id="startButton" onclick="startPressed();">Start</button>
    <div id="console"></div>
    <script>
      if (!isSupported()) log('Device not supported')
      else log('Device is supported')
    </script>

  </body>
  
</html>